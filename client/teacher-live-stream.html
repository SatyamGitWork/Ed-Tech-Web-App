<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Streaming - Teacher</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-logo">
            <a href="index.html" class="nav-logo-link">
                <img src="https://img.icons8.com/color/96/000000/graduation-cap.png" alt="Ed-Tech Logo" class="nav-logo-img">
                <span class="nav-logo-text">Ed-Tech</span>
            </a>
        </div>
        <div class="nav-links">
            <a href="teacher-dashboard.html">Dashboard</a>
            <a href="index.html">Home</a>
            <a href="chatbot.html">AI Assistant</a>
            <div class="auth-buttons">
                <div id="logged-in-nav" style="display: flex; gap: 1rem; align-items: center;">
                    <div class="notification-container" id="notification-bell">
                        <div class="notification-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                            </svg>
                            <span class="notification-badge" id="notification-count"></span>
                        </div>
                        <div class="notification-dropdown" id="notification-dropdown">
                            <div class="notification-header">
                                <h3>Notifications</h3>
                                <button id="mark-all-read" class="mark-all-read-btn">Mark all as read</button>
                            </div>
                            <div class="notification-list" id="notification-list"></div>
                            <div class="notification-footer">
                                <a href="notifications.html">View all notifications</a>
                            </div>
                        </div>
                    </div>
                    <div class="user-menu">
                        <button id="user-name" class="nav-username" onclick="toggleUserMenu()"></button>
                        <div class="user-dropdown" id="user-dropdown">
                            <a href="profile.html" class="user-dropdown-item">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                    <circle cx="12" cy="7" r="4"></circle>
                                </svg>
                                Profile
                            </a>
                            <a href="#" onclick="handleLogout(); return false;" class="user-dropdown-item logout">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                    <polyline points="16 17 21 12 16 7"></polyline>
                                    <line x1="21" y1="12" x2="9" y2="12"></line>
                                </svg>
                                Logout
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <main class="live-stream-container">
        <!-- Stream Header -->
        <div class="stream-header">
            <h1 id="streamTitle">Loading...</h1>
            <p id="courseTitle">Loading course...</p>
        </div>

        <div class="stream-layout">
            <!-- Video Section -->
            <div class="video-section">
                <!-- Video Preview -->
                <div class="video-container">
                    <video id="localVideo" autoplay muted playsinline></video>
                    <div class="video-overlay">
                        <div class="stream-status" id="streamStatus">
                            <span class="status-dot"></span>
                            <span id="statusText">Not Live</span>
                        </div>
                        <div class="viewer-count" id="viewerCount">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                <circle cx="12" cy="12" r="3"></circle>
                            </svg>
                            <span id="viewerCountText">0 viewers</span>
                        </div>
                    </div>
                </div>

                <!-- Stream Controls -->
                <div class="stream-controls">
                    <button id="setupCameraBtn" class="btn-primary">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M23 7l-7 5 7 5V7z"></path>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg>
                        Setup Camera
                    </button>
                    
                    <button id="goLiveBtn" class="btn-live" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <circle cx="12" cy="12" r="8"></circle>
                        </svg>
                        Go Live
                    </button>
                    
                    <button id="stopStreamBtn" class="btn-danger" disabled>
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="6" y="6" width="12" height="12"></rect>
                        </svg>
                        Stop Stream
                    </button>

                    <div class="control-spacer"></div>

                    <button id="toggleVideoBtn" class="btn-control" disabled title="Toggle Camera">
                        <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="currentColor"/>
                        </svg>
                    </button>
                    
                    <button id="toggleAudioBtn" class="btn-control" disabled title="Toggle Microphone">
                        <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" fill="currentColor"/>
                            <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" fill="currentColor"/>
                        </svg>
                    </button>
                </div>

                <!-- Recording Controls -->
                <div class="recording-controls">
                    <div class="recording-status-bar">
                        <div class="recording-indicator" id="recordingIndicator">
                            <span class="rec-dot"></span>
                            <span id="recordingStatusText">Not Recording</span>
                        </div>
                        <span class="recording-duration" id="recordingDuration">00:00</span>
                    </div>
                    <div class="recording-buttons">
                        <button id="startRecordingBtn" class="btn-record" disabled>
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <circle cx="12" cy="12" r="10"></circle>
                            </svg>
                            Start Recording
                        </button>
                        <button id="stopRecordingBtn" class="btn-stop-record" disabled style="display: none;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <rect x="6" y="6" width="12" height="12"></rect>
                            </svg>
                            Stop Recording
                        </button>
                        <button id="uploadRecordingBtn" class="btn-upload" disabled style="display: none;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            Upload to Drive
                        </button>
                    </div>
                    <div class="recording-info" id="recordingInfo" style="display: none;">
                        <p class="info-text">üìπ Recording saved locally. Click "Upload to Drive" to make it available to students.</p>
                        <div class="recording-file-info" id="recordingFileInfo"></div>
                    </div>
                </div>

                <!-- Stream Info -->
                <div class="stream-info">
                    <div class="info-card">
                        <h3>üìä Stream Statistics</h3>
                        <div class="stats-grid">
                            <div class="stat">
                                <span class="stat-label">Current Viewers</span>
                                <span class="stat-value" id="currentViewers">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Peak Viewers</span>
                                <span class="stat-value" id="peakViewers">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Chat Messages</span>
                                <span class="stat-value" id="messageCount">0</span>
                            </div>
                            <div class="stat">
                                <span class="stat-label">Duration</span>
                                <span class="stat-value" id="streamDuration">00:00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Section -->
            <div class="chat-section">
                <div class="chat-header">
                    <h3>üí¨ Live Chat</h3>
                    <span id="chatCount">0 messages</span>
                </div>
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-empty">
                        <p>No messages yet. Students will see questions here when they join.</p>
                    </div>
                </div>
                <div class="chat-input-container">
                    <input 
                        type="text" 
                        id="chatInput" 
                        class="chat-input" 
                        placeholder="Reply to students..."
                        maxlength="500"
                    >
                    <button id="sendChatBtn" class="chat-send-btn">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="22" y1="2" x2="11" y2="13"></line>
                            <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                        </svg>
                        Send
                    </button>
                </div>
            </div>
        </div>
    </main>

    <script src="script.js"></script>
    <script>
        // Note: API_URL is already defined in script.js
        // const SOCKET_URL = 'http://localhost:5000';
        const SOCKET_URL = 'https://ed-tech-web-app-79a4.onrender.com';
        
        // Safe showToast wrapper
        function safeShowToast(message, type = 'info') {
            if (typeof showToast === 'function') {
                showToast(message, type);
            } else {
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }
        
        let socket = null;
        let localStream = null;
        let streamKey = null;
        let courseId = null;
        let liveClassId = null;
        let isLive = false;
        let streamStartTime = null;
        let durationInterval = null;
        let currentViewerCount = 0;
        let peakViewerCount = 0;
        let messageCount = 0;
        let videoEnabled = true;
        let audioEnabled = true;

        // Recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let recordingDurationInterval = null;
        let recordedBlob = null;
        let isRecording = false;

        // Get stream info from URL
        const urlParams = new URLSearchParams(window.location.search);
        courseId = urlParams.get('courseId');
        liveClassId = urlParams.get('liveClassId');

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('üöÄ Page loaded - DOMContentLoaded fired');
            console.log('üìç Current URL:', window.location.href);
            console.log('üì¶ URL Parameters:', { courseId, liveClassId });
            
            checkAuthStatus();
            
            if (!courseId || !liveClassId) {
                console.error('‚ùå Missing URL parameters');
                alert('Invalid stream parameters. Please start from dashboard.');
                window.location.href = 'teacher-dashboard.html';
                return;
            }

            console.log('‚è≥ Loading live class details...');
            await loadLiveClassDetails();
            
            console.log('‚è≥ Setting up event listeners...');
            setupEventListeners();
            
            console.log('‚è≥ Connecting to socket...');
            connectSocket();
            
            console.log('‚úÖ Page initialization complete!');
        });

        // Load live class details
        async function loadLiveClassDetails() {
            try {
                const token = localStorage.getItem('userToken');
                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                if (data.success && data.liveClass) {
                    streamKey = data.liveClass.streamKey || `stream_${Date.now()}`;
                    document.getElementById('streamTitle').textContent = data.liveClass.title || 'Live Stream';
                    document.getElementById('courseTitle').textContent = data.course?.title || 'Course';
                    
                    // If stream is already live, allow resuming
                    if (data.liveClass.isLive) {
                        safeShowToast('‚ö†Ô∏è This stream is already live. Click "Go Live" to resume.', 'info');
                        // Enable go live button to allow resuming
                        document.getElementById('goLiveBtn').textContent = 'üîÑ Resume Stream';
                    }
                    
                    console.log('‚úÖ Live class loaded:', data.liveClass.title);
                } else {
                    throw new Error('Invalid response from server');
                }
            } catch (error) {
                console.error('Error loading live class:', error);
                alert(`Failed to load live class details: ${error.message}\n\nPlease check:\n1. Internet connection\n2. Server is running\n3. Course and live class exist`);
                
                // Don't redirect, let teacher try to refresh
                safeShowToast('Failed to load stream details. Please refresh the page.', 'error');
            }
        }

        // Setup event listeners
        function setupEventListeners() {
            console.log('üé¨ Setting up event listeners...');
            
            const setupCameraBtn = document.getElementById('setupCameraBtn');
            if (setupCameraBtn) {
                setupCameraBtn.addEventListener('click', async () => {
                    console.log('üé• Setup Camera button clicked!');
                    await setupCamera();
                });
                console.log('‚úÖ Setup Camera button listener attached');
            } else {
                console.error('‚ùå Setup Camera button not found!');
            }
            
            document.getElementById('goLiveBtn').addEventListener('click', goLive);
            document.getElementById('stopStreamBtn').addEventListener('click', stopStream);
            document.getElementById('toggleVideoBtn').addEventListener('click', toggleVideo);
            document.getElementById('toggleAudioBtn').addEventListener('click', toggleAudio);
            
            // Recording event listeners
            document.getElementById('startRecordingBtn').addEventListener('click', startRecording);
            document.getElementById('stopRecordingBtn').addEventListener('click', stopRecording);
            document.getElementById('uploadRecordingBtn').addEventListener('click', uploadRecording);
            
            // Chat event listeners
            document.getElementById('sendChatBtn').addEventListener('click', sendMessage);
            document.getElementById('chatInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            console.log('‚úÖ All event listeners attached');
        }

        // Store peer connections for each student
        const peerConnections = new Map(); // studentSocketId -> RTCPeerConnection
        
        // WebRTC configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Connect to Socket.io
        function connectSocket() {
            socket = io(SOCKET_URL);
            
            socket.on('connect', () => {
                console.log('‚úÖ Teacher connected to Socket.io server. Socket ID:', socket.id);
            });

            socket.on('new-viewer', async ({ userName, viewerCount, studentSocketId }) => {
                console.log(`üë• New viewer joined: ${userName} (Socket: ${studentSocketId})`);
                
                currentViewerCount = viewerCount;
                if (viewerCount > peakViewerCount) {
                    peakViewerCount = viewerCount;
                }
                updateViewerCount();
                safeShowToast(`${userName} joined the stream`, 'info');
                
                // Create peer connection for this student
                if (localStream && studentSocketId) {
                    await createPeerConnection(studentSocketId);
                }
            });

            socket.on('viewer-count-updated', ({ count }) => {
                currentViewerCount = count;
                if (count > peakViewerCount) {
                    peakViewerCount = count;
                }
                updateViewerCount();
            });
            
            // Handle answer from student
            socket.on('answer', async ({ answer, studentSocketId }) => {
                console.log('üì• Received answer from student:', studentSocketId);
                const peerConnection = peerConnections.get(studentSocketId);
                
                if (peerConnection) {
                    try {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                        console.log('‚úÖ Set remote description from student');
                    } catch (error) {
                        console.error('‚ùå Error setting remote description:', error);
                    }
                }
            });
            
            // Handle ICE candidates from students
            socket.on('ice-candidate', async ({ candidate, fromSocketId }) => {
                console.log('üßä Received ICE candidate from:', fromSocketId);
                const peerConnection = peerConnections.get(fromSocketId);
                
                if (peerConnection && candidate) {
                    try {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log('‚úÖ Added ICE candidate');
                    } catch (error) {
                        console.error('‚ùå Error adding ICE candidate:', error);
                    }
                }
            });

            socket.on('chat-message', (data) => {
                addChatMessage(data);
            });
            
            socket.on('student-left', ({ studentSocketId }) => {
                console.log('üëã Student left:', studentSocketId);
                const peerConnection = peerConnections.get(studentSocketId);
                if (peerConnection) {
                    peerConnection.close();
                    peerConnections.delete(studentSocketId);
                }
            });

            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from Socket.io server');
            });
        }
        
        // Create peer connection for a student
        async function createPeerConnection(studentSocketId) {
            try {
                console.log('üîó Creating peer connection for student:', studentSocketId);
                
                const peerConnection = new RTCPeerConnection(rtcConfig);
                
                // Add local stream tracks to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                    console.log('üì§ Added track to peer connection:', track.kind);
                });
                
                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        console.log('üßä Sending ICE candidate to student:', studentSocketId);
                        socket.emit('ice-candidate', {
                            streamKey,
                            candidate: event.candidate,
                            targetSocketId: studentSocketId
                        });
                    }
                };
                
                // Monitor connection state
                peerConnection.onconnectionstatechange = () => {
                    console.log(`Connection state for ${studentSocketId}:`, peerConnection.connectionState);
                };
                
                // Create and send offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                console.log('üì§ Sending offer to student:', studentSocketId);
                socket.emit('offer', {
                    streamKey,
                    offer: offer,
                    targetSocketId: studentSocketId
                });
                
                // Store peer connection
                peerConnections.set(studentSocketId, peerConnection);
                
                console.log('‚úÖ Peer connection created and offer sent');
            } catch (error) {
                console.error('‚ùå Error creating peer connection:', error);
            }
        }

        // Setup camera and microphone
        async function setupCamera() {
            console.log('üìπ setupCamera() function called!');
            console.log('üîç Checking browser support...');
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('‚ùå Your browser does not support camera/microphone access.\n\nPlease use a modern browser like Chrome, Firefox, or Edge.');
                console.error('‚ùå getUserMedia not supported');
                return;
            }
            
            console.log('‚úÖ Browser supports getUserMedia');
            
            try {
                console.log('üé• Requesting camera and microphone access...');
                
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                console.log('‚úÖ Got media stream:', localStream);
                console.log('üìä Video tracks:', localStream.getVideoTracks());
                console.log('üìä Audio tracks:', localStream.getAudioTracks());

                const videoElement = document.getElementById('localVideo');
                if (!videoElement) {
                    console.error('‚ùå Video element not found!');
                    return;
                }
                
                videoElement.srcObject = localStream;
                console.log('‚úÖ Video stream attached to element');

                // Enable controls
                document.getElementById('goLiveBtn').disabled = false;
                document.getElementById('toggleVideoBtn').disabled = false;
                document.getElementById('toggleAudioBtn').disabled = false;
                document.getElementById('setupCameraBtn').disabled = true;
                document.getElementById('startRecordingBtn').disabled = false;

                console.log('‚úÖ Camera setup complete!');
                safeShowToast('Camera and microphone ready!', 'success');
            } catch (error) {
                console.error('üí• Error accessing camera:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                
                // Provide specific error messages based on error type
                let errorMessage = 'Failed to access camera and microphone.\n\n';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage += '‚ùå Permission Denied\n\n';
                    errorMessage += 'Please check:\n';
                    errorMessage += '1. Browser permissions (click üîí in address bar)\n';
                    errorMessage += '2. System settings:\n';
                    errorMessage += '   ‚Ä¢ Windows: Settings ‚Üí Privacy ‚Üí Camera/Microphone\n';
                    errorMessage += '   ‚Ä¢ Mac: System Preferences ‚Üí Security ‚Üí Camera/Microphone\n';
                    errorMessage += '3. Make sure no other app is using the camera\n';
                    errorMessage += '4. Try refreshing the page and allow permissions';
                } else if (error.name === 'NotFoundError') {
                    errorMessage += '‚ùå Camera/Microphone Not Found\n\n';
                    errorMessage += 'Please check:\n';
                    errorMessage += '1. Camera and microphone are connected\n';
                    errorMessage += '2. Drivers are installed properly\n';
                    errorMessage += '3. Device is not disabled in Device Manager';
                } else if (error.name === 'NotReadableError') {
                    errorMessage += '‚ùå Camera/Microphone Already in Use\n\n';
                    errorMessage += 'Please close other apps using camera/microphone:\n';
                    errorMessage += '‚Ä¢ Zoom, Skype, Teams, etc.\n';
                    errorMessage += '‚Ä¢ Other browser tabs with camera access\n';
                    errorMessage += '‚Ä¢ Camera app on your device';
                } else {
                    errorMessage += `Error: ${error.name}\n`;
                    errorMessage += `Message: ${error.message}`;
                }
                
                alert(errorMessage);
                
                // Show a helpful toast message
                safeShowToast('Camera setup failed. Check permissions and try again.', 'error');
            }
        }

        // Go live
        async function goLive() {
            if (!localStream) {
                alert('Please setup camera first');
                return;
            }

            try {
                const token = localStorage.getItem('userToken');
                const userId = localStorage.getItem('userId');

                // Start stream on backend
                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}/start`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (data.success) {
                    isLive = true;
                    streamStartTime = Date.now();

                    // Emit start-stream event
                    const userName = localStorage.getItem('userName') || 'Teacher';
                    socket.emit('start-stream', {
                        streamKey,
                        userId,
                        userName,
                        courseId,
                        liveClassId
                    });

                    // Update UI
                    document.getElementById('statusText').textContent = 'LIVE';
                    document.getElementById('streamStatus').classList.add('live');
                    document.getElementById('goLiveBtn').disabled = true;
                    document.getElementById('stopStreamBtn').disabled = false;
                    document.getElementById('setupCameraBtn').disabled = true;

                    // Start duration counter
                    startDurationCounter();

                    const message = data.isResuming 
                        ? 'üîÑ Stream resumed! You are back LIVE.' 
                        : `‚úÖ You are now LIVE! ${data.notificationsSent} students notified.`;
                    
                    safeShowToast(message, 'success');

                    // AUTO-START RECORDING when going live
                    if (!isRecording) {
                        setTimeout(() => {
                            startRecording();
                            safeShowToast('üìπ Recording started automatically', 'info');
                        }, 1000); // Small delay to ensure stream is stable
                    }
                } else {
                    alert('Failed to start stream: ' + data.message);
                }
            } catch (error) {
                console.error('Error starting stream:', error);
                alert('Failed to start stream. Please try again.');
            }
        }

        // Stop stream
        async function stopStream() {
            if (!confirm('Are you sure you want to stop the stream?')) {
                return;
            }

            try {
                const token = localStorage.getItem('userToken');

                // AUTO-STOP RECORDING if it's still running
                if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
                    safeShowToast('‚èπÔ∏è Stopping recording...', 'info');
                    await stopRecording();
                    
                    // Wait for recording to fully stop and blob to be created
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }

                // Stop stream on backend
                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}/stop`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();

                if (data.success) {
                    isLive = false;

                    // Emit stop-stream event
                    socket.emit('stop-stream', { streamKey });

                    // AUTO-UPLOAD RECORDING to Drive if available
                    if (recordedBlob) {
                        safeShowToast('üì§ Auto-uploading recording to Drive...', 'info');
                        try {
                            await uploadRecordingAutomatically();
                        } catch (uploadError) {
                            console.error('Auto-upload failed:', uploadError);
                            safeShowToast('‚ö†Ô∏è Recording saved but upload failed. Check manually.', 'warning');
                        }
                    } else {
                        console.warn('No recording blob available for upload');
                    }

                    // Stop local stream
                    if (localStream) {
                        localStream.getTracks().forEach(track => track.stop());
                        localStream = null;
                    }

                    // Stop duration counter
                    if (durationInterval) {
                        clearInterval(durationInterval);
                    }

                    // Update UI
                    document.getElementById('statusText').textContent = 'Stream Ended';
                    document.getElementById('streamStatus').classList.remove('live');
                    document.getElementById('localVideo').srcObject = null;

                    // Show stats
                    alert(`Stream ended!\n\nPeak Viewers: ${data.stats.peakViewers}\nTotal Messages: ${data.stats.totalMessages}\n\nRecording ${recordedBlob ? 'uploaded to Drive' : 'not available'}`);

                    // Redirect to dashboard
                    setTimeout(() => {
                        window.location.href = 'teacher-dashboard.html';
                    }, 3000);
                }
            } catch (error) {
                console.error('Error stopping stream:', error);
                alert('Failed to stop stream');
            }
        }

        // Toggle video
        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoEnabled = !videoEnabled;
                videoTrack.enabled = videoEnabled;
                
                const btn = document.getElementById('toggleVideoBtn');
                btn.classList.toggle('muted', !videoEnabled);
                
                // Change icon based on state
                btn.innerHTML = videoEnabled 
                    ? '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="currentColor"/></svg>'
                    : '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 6.5l-4 4V7c0-.55-.45-1-1-1H9.82L21 17.18V6.5zM3.27 2L2 3.27 4.73 6H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.21 0 .39-.08.54-.18L19.73 21 21 19.73 3.27 2z" fill="currentColor"/></svg>';
                
                safeShowToast(videoEnabled ? 'üìπ Camera on' : 'üìπ Camera off', 'info');
            }
        }

        // Toggle audio
        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioEnabled = !audioEnabled;
                audioTrack.enabled = audioEnabled;
                
                const btn = document.getElementById('toggleAudioBtn');
                btn.classList.toggle('muted', !audioEnabled);
                
                // Change icon based on state
                btn.innerHTML = audioEnabled
                    ? '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" fill="currentColor"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" fill="currentColor"/></svg>'
                    : '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 11h-1.7c0 .74-.16 1.43-.43 2.05l1.23 1.23c.56-.98.9-2.09.9-3.28zm-4.02.17c0-.06.02-.11.02-.17V5c0-1.66-1.34-3-3-3S9 3.34 9 5v.18l5.98 5.99zM4.27 3L3 4.27l6.01 6.01V11c0 1.66 1.33 3 2.99 3 .22 0 .44-.03.65-.08l1.66 1.66c-.71.33-1.5.52-2.31.52-2.76 0-5.3-2.1-5.3-5.1H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c.91-.13 1.77-.45 2.54-.9L19.73 21 21 19.73 4.27 3z" fill="currentColor"/></svg>';
                
                safeShowToast(audioEnabled ? 'üé§ Microphone on' : 'üé§ Microphone off', 'info');
            }
        }

        // Update viewer count
        function updateViewerCount() {
            document.getElementById('viewerCountText').textContent = `${currentViewerCount} ${currentViewerCount === 1 ? 'viewer' : 'viewers'}`;
            document.getElementById('currentViewers').textContent = currentViewerCount;
            document.getElementById('peakViewers').textContent = peakViewerCount;
        }

        // Add chat message
        function addChatMessage(data) {
            const chatMessages = document.getElementById('chatMessages');
            const isEmpty = chatMessages.querySelector('.chat-empty');
            
            if (isEmpty) {
                isEmpty.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            // Highlight teacher's own messages
            const currentUserId = localStorage.getItem('userId');
            if (data.userId === currentUserId) {
                messageDiv.classList.add('own-message');
            }
            
            const time = new Date(data.timestamp).toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });

            messageDiv.innerHTML = `
                <div class="message-header">
                    <strong>${data.userName}</strong>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-text">${escapeHtml(data.message)}</div>
            `;

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            messageCount++;
            document.getElementById('messageCount').textContent = messageCount;
            document.getElementById('chatCount').textContent = `${messageCount} ${messageCount === 1 ? 'message' : 'messages'}`;
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Send chat message
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;
            
            if (!socket || !socket.connected) {
                safeShowToast('Not connected to chat. Please wait.', 'error');
                return;
            }

            console.log('üì§ Sending chat message:', message);
            
            socket.emit('chat-message', {
                streamKey,
                message
            });

            input.value = '';
        }

        // Start duration counter
        function startDurationCounter() {
            durationInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - streamStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('streamDuration').textContent = 
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isLive) {
                if (confirm('You are currently live. Are you sure you want to leave?')) {
                    stopStream();
                }
            }
        });

        // ===== RECORDING FUNCTIONS =====

        // Start recording
        async function startRecording() {
            if (!localStream) {
                safeShowToast('Please setup camera first!', 'error');
                return;
            }

            try {
                // Check browser support
                if (!MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                    if (!MediaRecorder.isTypeSupported('video/webm')) {
                        throw new Error('Browser does not support recording');
                    }
                }

                recordedChunks = [];
                
                // Create MediaRecorder with audio and video
                const options = {
                    mimeType: 'video/webm;codecs=vp9,opus',
                    videoBitsPerSecond: 2500000 // 2.5 Mbps for good quality
                };

                mediaRecorder = new MediaRecorder(localStream, options);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data && event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedBlob = new Blob(recordedChunks, { type: 'video/webm' });
                    const sizeMB = (recordedBlob.size / (1024 * 1024)).toFixed(2);
                    
                    document.getElementById('recordingFileInfo').innerHTML = `
                        <p>‚úÖ Recording saved: ${sizeMB} MB</p>
                        <p>File ready for upload to Google Drive</p>
                    `;
                    document.getElementById('recordingInfo').style.display = 'block';
                    document.getElementById('uploadRecordingBtn').disabled = false;
                    document.getElementById('uploadRecordingBtn').style.display = 'inline-flex';
                };

                // Start recording
                mediaRecorder.start(1000); // Collect data every second
                recordingStartTime = Date.now();
                isRecording = true;

                // Update UI
                document.getElementById('recordingIndicator').classList.add('recording');
                document.getElementById('recordingStatusText').textContent = 'Recording';
                document.getElementById('startRecordingBtn').style.display = 'none';
                document.getElementById('stopRecordingBtn').disabled = false;
                document.getElementById('stopRecordingBtn').style.display = 'inline-flex';

                // Start recording duration counter
                startRecordingDurationCounter();

                // Notify backend that recording started
                await updateRecordingStatus('recording');

                safeShowToast('üî¥ Recording started!', 'success');
            } catch (error) {
                console.error('Error starting recording:', error);
                safeShowToast('Failed to start recording: ' + error.message, 'error');
            }
        }

        // Stop recording
        async function stopRecording() {
            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                return Promise.resolve();
            }

            return new Promise((resolve, reject) => {
                try {
                    // Set up one-time listener for when recording stops
                    const originalOnStop = mediaRecorder.onstop;
                    mediaRecorder.onstop = () => {
                        // Call original handler to create blob
                        if (originalOnStop) {
                            originalOnStop();
                        }
                        
                        // Wait a bit for blob creation to complete
                        setTimeout(() => {
                            resolve();
                        }, 500);
                    };

                    mediaRecorder.stop();
                    clearInterval(recordingDurationInterval);
                    isRecording = false;

                    // Update UI
                    document.getElementById('recordingIndicator').classList.remove('recording');
                    document.getElementById('recordingStatusText').textContent = 'Recording Stopped';
                    document.getElementById('stopRecordingBtn').disabled = true;

                    // Calculate final duration
                    const durationSeconds = Math.floor((Date.now() - recordingStartTime) / 1000);
                    
                    // Notify backend
                    updateRecordingStatus('processing', durationSeconds);

                    safeShowToast('‚èπÔ∏è Recording stopped!', 'success');
                } catch (error) {
                    console.error('Error stopping recording:', error);
                    safeShowToast('Failed to stop recording', 'error');
                    reject(error);
                }
            });
        }

        // Upload recording to Google Drive
        async function uploadRecording() {
            if (!recordedBlob) {
                safeShowToast('No recording to upload', 'error');
                return;
            }

            const uploadBtn = document.getElementById('uploadRecordingBtn');
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';

            try {
                const token = localStorage.getItem('userToken');
                const formData = new FormData();
                
                // Get stream title for file naming
                const streamTitle = document.getElementById('streamTitle').textContent || 'Live Stream';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                const fileName = `${streamTitle.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.webm`;
                formData.append('video', recordedBlob, fileName);

                // Show upload progress
                safeShowToast('üì§ Uploading to Google Drive...', 'info');

                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}/upload-recording`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                const data = await response.json();

                if (data.success) {
                    safeShowToast(`‚úÖ Recording uploaded! ${data.notificationsSent} students notified.`, 'success');
                    
                    // Update UI
                    document.getElementById('recordingStatusText').textContent = 'Available on Drive';
                    document.getElementById('recordingInfo').innerHTML = `
                        <p>‚úÖ Recording successfully uploaded to Google Drive</p>
                        <p>üì§ ${data.fileSize ? (data.fileSize / (1024 * 1024)).toFixed(2) + ' MB' : 'File'} uploaded</p>
                        <p>üîî ${data.notificationsSent} students notified</p>
                        <a href="${data.recordingUrl}" target="_blank" class="btn-view-recording">View on Drive</a>
                    `;

                    // Reset recording state
                    recordedBlob = null;
                    recordedChunks = [];
                    uploadBtn.style.display = 'none';
                    document.getElementById('startRecordingBtn').style.display = 'inline-flex';
                    document.getElementById('startRecordingBtn').disabled = false;
                } else {
                    throw new Error(data.message || 'Upload failed');
                }
            } catch (error) {
                console.error('Error uploading recording:', error);
                safeShowToast('‚ùå Failed to upload recording: ' + error.message, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Retry Upload';
            }
        }

        // Auto-upload recording (called when stream ends)
        async function uploadRecordingAutomatically() {
            if (!recordedBlob) {
                console.warn('uploadRecordingAutomatically: No recordedBlob available');
                return;
            }

            console.log('Starting auto-upload. Blob size:', recordedBlob.size, 'bytes');

            try {
                const token = localStorage.getItem('userToken');
                const formData = new FormData();
                
                // Get stream title for file naming
                const streamTitle = document.getElementById('streamTitle').textContent || 'Live Stream';
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
                const fileName = `${streamTitle.replace(/[^a-z0-9]/gi, '_')}_${timestamp}.webm`;
                
                console.log('Uploading file:', fileName, 'to courseId:', courseId, 'liveClassId:', liveClassId);
                
                formData.append('video', recordedBlob, fileName);

                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}/upload-recording`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    body: formData
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Upload failed with status:', response.status, errorText);
                    throw new Error(`Upload failed: ${response.status} - ${errorText}`);
                }

                const data = await response.json();

                if (data.success) {
                    console.log('Upload successful!', data);
                    safeShowToast(`‚úÖ Recording auto-saved to Drive! ${data.notificationsSent || 0} students notified.`, 'success');
                    
                    // Update UI
                    document.getElementById('recordingStatusText').textContent = 'Auto-saved to Drive';
                    document.getElementById('recordingInfo').innerHTML = `
                        <p>‚úÖ Recording automatically uploaded to Google Drive</p>
                        <p>üìπ File: ${fileName}</p>
                        <p>üì§ ${data.fileSize ? (data.fileSize / (1024 * 1024)).toFixed(2) + ' MB' : (recordedBlob.size / (1024 * 1024)).toFixed(2) + ' MB'} uploaded</p>
                    `;

                    // Reset recording state
                    recordedBlob = null;
                    recordedChunks = [];
                } else {
                    throw new Error(data.message || 'Auto-upload failed');
                }
            } catch (error) {
                console.error('Error auto-uploading recording:', error);
                safeShowToast('‚ö†Ô∏è Recording saved locally but auto-upload failed. Use manual upload.', 'warning');
                // Keep the blob so manual upload can still work
            }
        }

        // Update recording status on backend
        async function updateRecordingStatus(status, duration = null) {
            try {
                const token = localStorage.getItem('userToken');
                const response = await fetch(`${API_URL}/courses/${courseId}/live-class/${liveClassId}/recording-status`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status, duration })
                });

                const data = await response.json();
                return data.success;
            } catch (error) {
                console.error('Error updating recording status:', error);
                return false;
            }
        }

        // Start recording duration counter
        function startRecordingDurationCounter() {
            recordingDurationInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('recordingDuration').textContent = 
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        // Auto-enable recording when camera is set up - integrated into setupCamera function
        // The setupCamera function already handles enabling recording button

        // Note: To auto-start recording when going live, add this code at the end of goLive function:
        // if (isLive && !isRecording) await startRecording();

    </script>
</body>
</html>
